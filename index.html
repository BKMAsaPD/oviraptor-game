<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D å·è›‹é¾ï¼šé©šé­‚å¤œ (é›™æ‰‹æ“æ§ç‰ˆ)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');
        body { margin: 0; overflow: hidden; font-family: 'Noto Sans TC', sans-serif; background-color: #111827; user-select: none; touch-action: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; }
        .center-screen { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; pointer-events: auto; }
        .hidden { display: none !important; }
        
        /* ç´…ç‡ˆç¶ ç‡ˆ */
        #traffic-light {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: #22c55e;
            box-shadow: 0 0 25px #22c55e;
            transition: all 0.2s;
            margin: 0 auto;
            border: 4px solid rgba(255,255,255,0.4);
        }
        .light-red { background-color: #ef4444 !important; box-shadow: 0 0 40px #ef4444 !important; animation: pulse-red 0.5s infinite; }
        .light-yellow { background-color: #eab308 !important; box-shadow: 0 0 25px #eab308 !important; }
        
        @keyframes pulse-red {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        #game-container { width: 100vw; height: 100vh; position: relative; }
        canvas { width: 100%; height: 100%; display: block; }
        
        /* æº–å¿ƒ */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 0 2px black;
        }
        
        /* è™›æ“¬æ–æ¡¿ */
        #joystick-zone {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 140px;
            height: 140px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
            z-index: 20;
            display: none; /* æ‰‹æ©Ÿç‰ˆé¡¯ç¤º */
        }

        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            pointer-events: none;
        }
        
        /* å³å´è¦–è§’æ§åˆ¶æç¤ºå€ (éš±å½¢ä½†å¯è§¸æ§) */
        #touch-look-zone {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%; 
            height: 100%;
            z-index: 15;
            /* background: rgba(255,0,0,0.1); debug only */ 
        }

        /* æ‰‹æ©Ÿç‰ˆé¡¯ç¤ºæ–æ¡¿ */
        @media (max-width: 768px) {
            #joystick-zone { display: block; }
            #hint-text { font-size: 0.9rem; padding: 0.5rem 1rem; }
        }
    </style>
</head>
<body>

    <div id="game-container"></div>
    <div id="crosshair"></div>
    
    <!-- è™›æ“¬æ–æ¡¿ (å·¦æ‰‹ç§»å‹•) -->
    <div id="joystick-zone">
        <div id="joystick-knob"></div>
    </div>

    <!-- UI å±¤ -->
    <div id="ui-layer">
        <!-- é ‚éƒ¨è³‡è¨Š -->
        <div class="flex justify-between items-start w-full">
            <div class="bg-gray-900/70 backdrop-blur-md p-4 rounded-xl border border-gray-600 text-white min-w-[120px]">
                <div class="text-xs text-gray-400 uppercase tracking-wider">Score</div>
                <div class="text-3xl font-mono font-bold text-green-400">ğŸ¥š <span id="score-display">0</span></div>
            </div>
            
            <div class="flex flex-col items-center">
                <div id="traffic-light"></div>
                <div id="boss-status" class="mt-2 font-bold text-sm bg-black/50 px-2 py-1 rounded text-white border border-white/20">å®‰å…¨</div>
            </div>

            <div class="bg-gray-900/70 backdrop-blur-md p-4 rounded-xl border border-gray-600 text-white text-right min-w-[120px]">
                <div class="text-xs text-gray-400 uppercase tracking-wider">Distance</div>
                <div class="text-3xl font-mono font-bold text-yellow-400"><span id="dist-display">60</span>m</div>
            </div>
        </div>

        <!-- ä¸­é–“ä»»å‹™æç¤º -->
        <div id="objective-msg" class="absolute top-1/4 left-1/2 transform -translate-x-1/2 text-center w-full pointer-events-none transition-opacity duration-500 opacity-0">
            <h2 class="text-4xl font-bold text-white drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)] stroke-black" style="-webkit-text-stroke: 1px black;">
                ä»»å‹™æ›´æ–°
            </h2>
        </div>

        <!-- åº•éƒ¨æç¤º -->
        <div class="text-center pb-10 pointer-events-none">
            <p id="hint-text" class="text-white text-lg bg-green-800/80 inline-block px-8 py-3 rounded-full backdrop-blur-md border border-green-400/50 shadow-lg transition-colors duration-300 font-bold tracking-wide">
                ç›®æ¨™ï¼šæ½›å…¥å·¢ç©´å·è›‹ï¼
            </p>
            <p id="lock-hint" class="text-yellow-300 text-sm mt-2 hidden bg-black/60 inline-block px-3 py-1 rounded border border-yellow-500/30 pointer-events-auto">é»æ“Šç•«é¢é–å®šæ¸¸æ¨™(é›»è…¦ç‰ˆ)</p>
        </div>
    </div>

    <!-- é–‹å§‹ç•«é¢ -->
    <div id="start-screen" class="center-screen bg-gray-800/95 backdrop-blur-xl p-8 rounded-3xl border-2 border-green-600 text-white w-[90%] max-w-md shadow-2xl z-50">
        <h1 class="text-5xl font-bold mb-2 text-green-400 tracking-tighter">ğŸ¦– å·è›‹å¤§ä½œæˆ°</h1>
        <p class="text-gray-300 mb-6 font-medium">é›™æ‰‹æ“æ§ç‰ˆ</p>
        <div class="text-left bg-black/30 p-5 rounded-xl mb-8 text-sm text-gray-200 space-y-3 border border-gray-600">
            <p>ğŸ•¹ï¸ <strong class="text-blue-300">å·¦æ‰‹æ–æ¡¿ï¼š</strong> æ§åˆ¶å‰å¾Œå·¦å³ç§»å‹• (WASD)ã€‚</p>
            <p>ğŸ‘€ <strong class="text-blue-400">å³æ‰‹æ»‘å‹•ï¼š</strong> æ§åˆ¶è¦–è§’è½‰å‹•ã€‚</p>
            <p>1ï¸âƒ£ <strong class="text-yellow-400">æ½›å…¥ï¼š</strong> è¶æš´é¾ç¡è¦ºï¼Œç”¨åˆ©çˆªå·èµ°æé¾è›‹ã€‚</p>
            <p>2ï¸âƒ£ <strong class="text-purple-400">è² é‡ï¼š</strong> å·åˆ°è›‹å¾Œ<span class="text-red-400 font-bold">ç§»å‹•è®Šæ…¢</span>ï¼Œè¦æ›´å°å¿ƒã€‚</p>
            <p>âš ï¸ <strong class="text-red-400">è¦å‰‡ï¼š</strong> ç´…ç‡ˆæ™‚ <span class="underline decoration-red-500">çµ•å°ä¸å‹•</span>ã€‚</p>
        </div>
        <button id="start-btn" class="w-full bg-gradient-to-r from-green-600 to-emerald-500 hover:from-green-500 hover:to-emerald-400 text-white font-bold py-4 rounded-2xl text-xl transition transform hover:scale-[1.02] shadow-lg border-b-4 border-green-800">
            é–‹å§‹è¡Œå‹•
        </button>
    </div>

    <!-- éŠæˆ²çµæŸç•«é¢ -->
    <div id="end-screen" class="center-screen bg-red-950/95 backdrop-blur-xl p-8 rounded-3xl border-2 border-red-500 text-white w-[90%] max-w-md shadow-2xl z-50 hidden">
        <div class="text-7xl mb-4">ğŸ¦–</div>
        <h2 class="text-5xl font-bold mb-2 text-red-500">è¢«æŠ“åˆ°äº†ï¼</h2>
        <p class="text-xl text-gray-300 mb-4">æš´é¾æŠŠä½ ç•¶æˆäº†é»å¿ƒ...</p>
        <div class="bg-black/50 p-4 rounded-xl mb-8 border border-red-900">
            <p class="text-gray-400 text-sm">æœ¬æ¬¡æˆç¸¾</p>
            <p class="text-4xl font-bold text-yellow-400"><span id="final-score">0</span> é¡†è›‹</p>
        </div>
        <button id="restart-btn" class="w-full bg-white text-red-900 hover:bg-gray-200 font-bold py-4 rounded-2xl text-xl transition shadow-lg">
            å†æ¬¡æŒ‘æˆ°
        </button>
    </div>

    <script>
        // --- éŠæˆ²åƒæ•¸ ---
        const CONFIG = {
            startDistance: 60,
            nestDistance: 7,
            moveSpeed: 0.06,   // æ…¢é€Ÿæ½›è¡Œ
            eggWeightFactor: 0.6, 
            bossScale: 3,
            fogDensity: 0.012, 
            mouseSensitivity: 0.002,
            touchLookSensitivity: 0.005
        };

        // --- å…¨åŸŸè®Šæ•¸ ---
        let scene, camera, renderer;
        let eggMesh, nestGroup, playerNestGroup;
        let handsGroup, eggInHand; 
        
        let player = { 
            x: 0, y: 2, z: CONFIG.startDistance, 
            pitch: 0, yaw: 0,
            isMoving: false, 
            dead: false, 
            hasEgg: false,
            score: 0,
            grabAnim: 0 
        };
        
        let boss = { mesh: null, state: 'sleep', turnProgress: 0 }; 
        let lastTime = 0;
        let bossTimer = 0;
        let nextStateTime = 3000;
        let difficulty = 1.0;

        let isPointerLocked = false;
        
        // è¼¸å…¥ç‹€æ…‹
        const inputs = { w: false, a: false, s: false, d: false };
        // æ–æ¡¿ç‹€æ…‹ (ç§»å‹•)
        const joystick = { active: false, dx: 0, dy: 0, originX: 0, originY: 0, touchId: null };
        // è§¸æ§è¦–è§’ç‹€æ…‹
        const touchLook = { active: false, lastX: 0, lastY: 0, touchId: null };

        const ui = {
            startScreen: document.getElementById('start-screen'),
            endScreen: document.getElementById('end-screen'),
            scoreDisplay: document.getElementById('score-display'),
            finalScore: document.getElementById('final-score'),
            distDisplay: document.getElementById('dist-display'),
            trafficLight: document.getElementById('traffic-light'),
            bossStatus: document.getElementById('boss-status'),
            hintText: document.getElementById('hint-text'),
            lockHint: document.getElementById('lock-hint'),
            restartBtn: document.getElementById('restart-btn'),
            startBtn: document.getElementById('start-btn'),
            gameContainer: document.getElementById('game-container'),
            objectiveMsg: document.getElementById('objective-msg'),
            joystickZone: document.getElementById('joystick-zone'),
            joystickKnob: document.getElementById('joystick-knob')
        };

        // --- Three.js åˆå§‹åŒ– ---
        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2332); 
            scene.fog = new THREE.FogExp2(0x1a2332, CONFIG.fogDensity);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ'; 
            
            scene.add(camera); 
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            ui.gameContainer.appendChild(renderer.domElement);

            // ç‡ˆå…‰
            const ambientLight = new THREE.AmbientLight(0xb0c4de, 0.7); 
            scene.add(ambientLight);

            const moonLight = new THREE.DirectionalLight(0xffffff, 0.5);
            moonLight.position.set(50, 100, 50);
            moonLight.castShadow = true;
            moonLight.shadow.camera.top = 50;
            moonLight.shadow.camera.bottom = -50;
            moonLight.shadow.camera.left = -50;
            moonLight.shadow.camera.right = 50;
            moonLight.shadow.mapSize.width = 2048;
            moonLight.shadow.mapSize.height = 2048;
            scene.add(moonLight);

            const spotLight = new THREE.SpotLight(0xffd700, 1.2);
            spotLight.position.set(0, 25, -10);
            spotLight.angle = 0.5;
            spotLight.penumbra = 0.4;
            spotLight.castShadow = true;
            spotLight.shadow.bias = -0.0001;
            scene.add(spotLight);

            // åœ°é¢
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x2d3728, 
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            createBoss();
            createEnvironment();
            createTargetNest(); 
            createPlayerNest(); 
            createPlayerHands(); 

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('pointerlockchange', onPointerLockChange, false);
            
            ui.gameContainer.addEventListener('click', () => {
                if (!player.dead && !isPointerLocked && !joystick.active && !touchLook.active) {
                    if(window.innerWidth > 768) { 
                        ui.gameContainer.requestPointerLock();
                    }
                }
            });

            initInputs();
        }

        // --- ç©å®¶çš„æ‰‹ (çˆªå­ + è›‹) ---
        function createPlayerHands() {
            handsGroup = new THREE.Group();
            camera.add(handsGroup); 
            
            const handLight = new THREE.PointLight(0xffffff, 0.3, 2);
            handLight.position.set(0, 0, 0);
            camera.add(handLight);

            handsGroup.position.set(0, -0.2, -0.6);
            handsGroup.scale.set(1.8, 1.8, 1.8);

            const skinMat = new THREE.MeshStandardMaterial({ color: 0x556b2f, roughness: 0.7 }); 
            const clawMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.4, metalness: 0.5 }); 

            function createClawHand(isLeft) {
                const hand = new THREE.Group();
                const side = isLeft ? -1 : 1;

                const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.07, 0.5), skinMat);
                arm.rotation.x = Math.PI / 2;
                arm.position.set(0, 0, 0.25);
                hand.add(arm);

                const palm = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.08, 0.15), skinMat);
                palm.position.set(0, 0, -0.02);
                hand.add(palm);

                for(let i=-1; i<=1; i++) {
                    const fingerGroup = new THREE.Group();
                    const finger = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.02, 0.12), skinMat);
                    finger.rotation.x = Math.PI / 2;
                    finger.position.set(i*0.04, 0, -0.08);
                    fingerGroup.add(finger);
                    const tip = new THREE.Mesh(new THREE.ConeGeometry(0.012, 0.15, 8), clawMat);
                    tip.rotation.x = -Math.PI / 2;
                    tip.position.set(i*0.04, -0.01, -0.2);
                    fingerGroup.add(tip);
                    
                    hand.add(fingerGroup);
                }

                hand.position.set(side * 0.3, -0.2, 0); 
                hand.rotation.set(0.2, side * -0.2, 0);
                return hand;
            }

            handsGroup.add(createClawHand(true));  
            handsGroup.add(createClawHand(false)); 

            const eggGeo = new THREE.SphereGeometry(0.22, 32, 32).scale(1, 1.4, 1);
            const eggMat = new THREE.MeshStandardMaterial({ 
                color: 0xfffdd0, 
                emissive: 0x222200, 
                roughness: 0.3 
            });
            eggInHand = new THREE.Mesh(eggGeo, eggMat);
            eggInHand.position.set(0, -0.1, -0.1); 
            eggInHand.rotation.z = 0.2;
            eggInHand.visible = false; 
            handsGroup.add(eggInHand);
        }

        // --- è¼¸å…¥é‚è¼¯ (æ–æ¡¿ + è§¸æ§è¦–è§’ + éµç›¤) ---
        function initInputs() {
            // 1. è™›æ“¬æ–æ¡¿ (ç§»å‹•: å‰å¾Œå·¦å³)
            const joyZone = ui.joystickZone;
            const joyKnob = ui.joystickKnob;
            const maxRadius = 40;

            joyZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation(); // é˜²æ­¢è§¸ç™¼è¦–è§’æ§åˆ¶
                const touch = e.changedTouches[0];
                const rect = joyZone.getBoundingClientRect();
                
                joystick.active = true;
                joystick.touchId = touch.identifier;
                joystick.originX = rect.left + rect.width / 2;
                joystick.originY = rect.top + rect.height / 2;
                
                updateJoystick(touch.clientX, touch.clientY);
            }, {passive: false});

            joyZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                e.stopPropagation();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystick.touchId) {
                        updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                        break;
                    }
                }
            }, {passive: false});

            const joyEnd = (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystick.touchId) {
                        joystick.active = false;
                        joystick.dx = 0;
                        joystick.dy = 0;
                        joystick.touchId = null;
                        joyKnob.style.transform = `translate(-50%, -50%)`;
                        break;
                    }
                }
            };
            joyZone.addEventListener('touchend', joyEnd);
            joyZone.addEventListener('touchcancel', joyEnd);

            function updateJoystick(clientX, clientY) {
                let dx = clientX - joystick.originX;
                let dy = clientY - joystick.originY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > maxRadius) {
                    const angle = Math.atan2(dy, dx);
                    dx = Math.cos(angle) * maxRadius;
                    dy = Math.sin(angle) * maxRadius;
                }

                joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                // æ­£è¦åŒ–è¼¸å‡º (-1 ~ 1)
                joystick.dx = dx / maxRadius;
                joystick.dy = dy / maxRadius;
            }

            // 2. å…¨è¢å¹•è§¸æ§ (è¦–è§’: è½‰é ­/æŠ¬é ­)
            // é¿é–‹æ–æ¡¿å€åŸŸ
            ui.gameContainer.addEventListener('touchstart', (e) => {
                if(e.target === joyZone || e.target === joyKnob) return;
                
                // æ‰¾åˆ°ç¬¬ä¸€å€‹ä¸æ˜¯æ–æ¡¿çš„è§¸æ§é»
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.identifier !== joystick.touchId) {
                        touchLook.active = true;
                        touchLook.touchId = t.identifier;
                        touchLook.lastX = t.clientX;
                        touchLook.lastY = t.clientY;
                        break;
                    }
                }
            }, {passive: false});

            ui.gameContainer.addEventListener('touchmove', (e) => {
                if (!touchLook.active) return;
                e.preventDefault(); // é˜²æ­¢æ»¾å‹•
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.identifier === touchLook.touchId) {
                        const deltaX = t.clientX - touchLook.lastX;
                        const deltaY = t.clientY - touchLook.lastY;
                        
                        // æ›´æ–°è¦–è§’
                        player.yaw -= deltaX * CONFIG.touchLookSensitivity;
                        player.pitch -= deltaY * CONFIG.touchLookSensitivity;
                        player.pitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, player.pitch));

                        touchLook.lastX = t.clientX;
                        touchLook.lastY = t.clientY;
                        break;
                    }
                }
            }, {passive: false});

            const lookEnd = (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchLook.touchId) {
                        touchLook.active = false;
                        touchLook.touchId = null;
                        break;
                    }
                }
            };
            ui.gameContainer.addEventListener('touchend', lookEnd);
            ui.gameContainer.addEventListener('touchcancel', lookEnd);

            // 3. éµç›¤æ§åˆ¶ (é›»è…¦ç‰ˆ)
            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (inputs.hasOwnProperty(key)) inputs[key] = true;
            });
            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (inputs.hasOwnProperty(key)) inputs[key] = false;
            });
        }

        // --- è±ªè¯ç©å®¶å·¢ç©´ ---
        function createPlayerNest() {
            playerNestGroup = new THREE.Group();
            scene.add(playerNestGroup);

            const woodMat = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.9 });
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x2e4e2e, side: THREE.DoubleSide });

            for (let i = 0; i < 14; i++) {
                const height = 2.0 + Math.random() * 1.5;
                const log = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, height, 6), woodMat);
                const angle = (i / 14) * Math.PI * 2;
                const radius = 3.5;
                if (Math.abs(angle - Math.PI * 1.5) < 0.6) continue;
                log.position.set(Math.cos(angle) * radius, height / 2, Math.sin(angle) * radius);
                log.lookAt(0, height + 2, 0); 
                log.castShadow = true;
                log.receiveShadow = true;
                playerNestGroup.add(log);
            }

            for (let i = 0; i < 30; i++) {
                const branch = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.08, 2.5, 4), woodMat);
                const angle = Math.random() * Math.PI * 2;
                const radius = 3.6;
                if (Math.abs(angle - Math.PI * 1.5) < 0.7) continue;
                branch.position.set(Math.cos(angle) * radius, 0.5 + Math.random() * 1.5, Math.sin(angle) * radius);
                branch.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                branch.castShadow = true;
                playerNestGroup.add(branch);
            }

            for (let i = 0; i < 25; i++) {
                const leaf = new THREE.Mesh(new THREE.ConeGeometry(1.2, 0.5, 5), leafMat);
                leaf.position.set((Math.random()-0.5)*5, 2.5 + Math.random(), (Math.random()-0.5)*5);
                leaf.rotation.set(Math.random(), Math.random(), Math.random());
                leaf.castShadow = true;
                playerNestGroup.add(leaf);
            }

            const shellMat = new THREE.MeshStandardMaterial({ color: 0xeee8aa, side: THREE.DoubleSide });
            for (let i = 0; i < 10; i++) {
                const shell = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.6), shellMat);
                shell.position.set((Math.random()-0.5)*2.5, 0.05, (Math.random()-0.5)*2.5);
                shell.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                shell.castShadow = true;
                playerNestGroup.add(shell);
            }

            playerNestGroup.position.set(0, 0, CONFIG.startDistance);
        }

        // --- Boss çš„å·¢ç©´ ---
        function createTargetNest() {
            nestGroup = new THREE.Group();
            scene.add(nestGroup);

            eggMesh = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32).scale(1, 1.4, 1), new THREE.MeshStandardMaterial({ color: 0xfffdd0, roughness: 0.3, metalness: 0.1 }));
            eggMesh.position.set(0, 0.8, 0); 
            eggMesh.castShadow = true;
            eggMesh.rotation.z = 0.2;
            nestGroup.add(eggMesh);

            const twigGeo = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 5);
            const twigMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });

            for (let i = 0; i < 80; i++) {
                const twig = new THREE.Mesh(twigGeo, twigMat);
                const angle = Math.random() * Math.PI * 2;
                const radius = 1.5 + Math.random() * 0.8;
                twig.position.set(Math.cos(angle) * radius, 0.2 + Math.random() * 0.3, Math.sin(angle) * radius);
                twig.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                twig.castShadow = true;
                twig.receiveShadow = true;
                nestGroup.add(twig);
            }

            const base = new THREE.Mesh(new THREE.CylinderGeometry(2, 3, 0.5, 16), new THREE.MeshStandardMaterial({ color: 0x3e2723 }));
            base.position.y = 0;
            base.receiveShadow = true;
            nestGroup.add(base);

            nestGroup.position.set(0, 0, 5);
        }

        function createBoss() {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0x4ade80, roughness: 0.6 });
            
            const body = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 4), mat); body.position.y = 3; body.castShadow = true; group.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 2), mat); head.position.set(0, 5, 2); head.castShadow = true; group.add(head);
            const eyeGeo = new THREE.SphereGeometry(0.2, 8, 8);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat); leftEye.position.set(-0.8, 5.2, 2.5); leftEye.name = "eyeL"; leftEye.visible = false; group.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat); rightEye.position.set(0.8, 5.2, 2.5); rightEye.name = "eyeR"; rightEye.visible = false; group.add(rightEye);
            const tail = new THREE.Mesh(new THREE.ConeGeometry(0.8, 4, 4), mat); tail.rotation.x = -Math.PI / 2; tail.position.set(0, 3, -3); group.add(tail);
            const legL = new THREE.Mesh(new THREE.BoxGeometry(0.8, 2, 1), mat); legL.position.set(-1, 1, 0); group.add(legL);
            const legR = new THREE.Mesh(new THREE.BoxGeometry(0.8, 2, 1), mat); legR.position.set(1, 1, 0); group.add(legR);
            const armGeo = new THREE.BoxGeometry(0.3, 0.8, 0.3);
            const armL = new THREE.Mesh(armGeo, mat); armL.position.set(-1.1, 3.5, 1.5); armL.rotation.x = -Math.PI/4; group.add(armL);
            const armR = new THREE.Mesh(armGeo, mat); armR.position.set(1.1, 3.5, 1.5); armR.rotation.x = -Math.PI/4; group.add(armR);

            group.scale.set(CONFIG.bossScale, CONFIG.bossScale, CONFIG.bossScale);
            group.position.set(0, 0, -10);
            group.rotation.y = Math.PI; 

            scene.add(group);
            boss.mesh = group;
        }

        function createEnvironment() {
            const treeGeo = new THREE.CylinderGeometry(0.5, 1.2, 9, 7);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 }); 
            const leavesGeo = new THREE.ConeGeometry(3, 6, 8);
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x1e3f20 }); 

            for (let i = 0; i < 60; i++) {
                const treeGroup = new THREE.Group();
                const trunk = new THREE.Mesh(treeGeo, trunkMat);
                trunk.position.y = 4.5; trunk.castShadow = true; treeGroup.add(trunk);
                const leaves = new THREE.Mesh(leavesGeo, leavesMat);
                leaves.position.y = 9; leaves.castShadow = true; treeGroup.add(leaves);
                let x = (Math.random() - 0.5) * 140; if (Math.abs(x) < 18) x += 30 * Math.sign(x); 
                const z = (Math.random() - 0.5) * 140;
                const s = 0.8 + Math.random() * 0.5;
                treeGroup.scale.set(s, s, s); treeGroup.position.set(x, 0, z);
                scene.add(treeGroup);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            if (!isPointerLocked || player.dead) return;
            player.yaw -= event.movementX * CONFIG.mouseSensitivity;
            player.pitch -= event.movementY * CONFIG.mouseSensitivity;
            player.pitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, player.pitch));
        }

        function onPointerLockChange() {
            isPointerLocked = document.pointerLockElement === ui.gameContainer;
            ui.lockHint.classList.toggle('hidden', isPointerLocked);
        }

        // --- éŠæˆ²é‚è¼¯ ---
        function startGame() {
            player.x = 0; player.y = 2; player.z = CONFIG.startDistance;
            player.yaw = 0; player.pitch = 0;
            player.dead = false; player.hasEgg = false; player.score = 0;
            player.isMoving = false; player.grabAnim = 0;
            difficulty = 1.0;
            
            boss.state = 'sleep'; bossTimer = 0; boss.mesh.rotation.y = Math.PI;
            eggMesh.visible = true;
            eggInHand.visible = false;
            
            ui.scoreDisplay.innerText = "0";
            ui.joystickZone.style.display = "block"; 
            
            updateObjectiveUI();
            setUiState('playing');
            
            // é›»è…¦ç‰ˆæ‰é–å®šé¼ æ¨™
            if (window.innerWidth > 768) {
                ui.gameContainer.requestPointerLock();
            }
            
            lastTime = performance.now();
            animate();
        }

        function endGame() {
            player.dead = true;
            document.exitPointerLock();
            ui.finalScore.innerText = player.score;
            ui.joystickZone.style.display = "none";
            setUiState('lose');
        }

        function showObjectiveMessage(text, colorClass) {
            const el = ui.objectiveMsg;
            el.innerHTML = `<h2 class="text-5xl font-bold ${colorClass} drop-shadow-lg stroke-black" style="-webkit-text-stroke: 2px black;">${text}</h2>`;
            el.style.opacity = 1;
            el.style.transform = "translate(-50%, -50%) scale(1.2)";
            
            setTimeout(() => {
                el.style.opacity = 0;
                el.style.transform = "translate(-50%, -50%) scale(1)";
            }, 2000);
        }

        function updateObjectiveUI() {
            if (!player.hasEgg) {
                ui.hintText.innerText = "ç›®æ¨™ï¼šæ½›å…¥å‰æ–¹å·¢ç©´å·è›‹ï¼";
                ui.hintText.className = "text-white text-lg bg-green-800/80 inline-block px-8 py-3 rounded-full backdrop-blur-md border border-green-400/50 shadow-lg transition-colors duration-300 font-bold tracking-wide";
            } else {
                ui.hintText.innerText = "ç›®æ¨™ï¼šå¸¶è‘—è›‹è·‘å›èµ·é»ï¼";
                ui.hintText.className = "text-white text-lg bg-yellow-600/80 inline-block px-8 py-3 rounded-full backdrop-blur-md border border-yellow-300/50 shadow-lg transition-colors duration-300 animate-pulse font-bold tracking-wide";
            }
        }

        function updateBoss(dt) {
            bossTimer += dt;
            const speedFactor = difficulty; 

            if (bossTimer > nextStateTime) {
                bossTimer = 0;
                if (boss.state === 'sleep') {
                    boss.state = 'warning'; 
                    nextStateTime = (1500 + Math.random() * 1500) / speedFactor;
                    setLight('yellow');
                } else if (boss.state === 'warning') {
                    boss.state = 'turning'; 
                    nextStateTime = 600 / speedFactor; 
                    setLight('red');
                } else if (boss.state === 'awake') {
                    boss.state = 'turning_back'; 
                    nextStateTime = 800 / speedFactor;
                    setLight('yellow');
                }
            }

            if (boss.state === 'turning') {
                boss.mesh.rotation.y = THREE.MathUtils.lerp(boss.mesh.rotation.y, 0, 0.15);
                if (Math.abs(boss.mesh.rotation.y) < 0.1) {
                    boss.state = 'awake'; bossTimer = 0; 
                    nextStateTime = (1500 + Math.random() * 1000);
                    boss.mesh.getObjectByName("eyeL").visible = true; 
                    boss.mesh.getObjectByName("eyeR").visible = true;
                }
            } else if (boss.state === 'turning_back') {
                boss.mesh.rotation.y = THREE.MathUtils.lerp(boss.mesh.rotation.y, Math.PI, 0.15);
                boss.mesh.getObjectByName("eyeL").visible = false; 
                boss.mesh.getObjectByName("eyeR").visible = false;
                if (Math.abs(boss.mesh.rotation.y - Math.PI) < 0.1) {
                    boss.state = 'sleep'; bossTimer = 0; 
                    nextStateTime = (2000 + Math.random() * 2000) / speedFactor;
                    setLight('green');
                }
            } else if (boss.state === 'sleep') {
                boss.mesh.scale.y = CONFIG.bossScale + Math.sin(Date.now() * 0.002) * 0.1;
            }
        }

        function setLight(color) {
            const el = ui.trafficLight;
            const status = ui.bossStatus;
            el.className = "";
            if (color === 'green') {
                el.style.backgroundColor = "#22c55e";
                el.style.boxShadow = "0 0 25px #22c55e";
                status.innerText = "å®‰å…¨ (ç¡è¦º)";
                status.className = "mt-2 font-bold text-sm bg-green-900/60 px-2 py-1 rounded text-green-200 border border-green-500/30";
            } else if (color === 'yellow') {
                el.className = "light-yellow";
                status.innerText = "è­¦æˆ’ (é†’ä¾†ä¸­)";
                status.className = "mt-2 font-bold text-sm bg-yellow-900/60 px-2 py-1 rounded text-yellow-200 border border-yellow-500/30";
            } else if (color === 'red') {
                el.className = "light-red";
                status.innerText = "å±éšª (åˆ¥å‹•!)";
                status.className = "mt-2 font-bold text-sm bg-red-900/60 px-2 py-1 rounded text-red-200 border border-red-500/30";
            }
        }

        function updatePlayer(dt) {
            if (player.dead) return;

            // --- ç§»å‹•è¨ˆç®— (WASD æˆ– æ–æ¡¿) ---
            let moveForward = 0;
            let strafe = 0;

            if (joystick.active) {
                // æ–æ¡¿æ§åˆ¶ç§»å‹•: 
                // dy: -1(ä¸Š) ~ 1(ä¸‹)  ->  å‰é€²éœ€è¦ +1, å¾Œé€€ -1  =>  moveForward = -dy
                // dx: -1(å·¦) ~ 1(å³)  ->  å·¦ç§» -1, å³ç§» +1      =>  strafe = dx
                moveForward = -joystick.dy;
                strafe = joystick.dx; 
            } else {
                // éµç›¤æ§åˆ¶
                if (inputs.w) moveForward = 1;
                if (inputs.s) moveForward = -1;
                if (inputs.a) strafe = -1;
                if (inputs.d) strafe = 1;
            }

            // åˆ¤æ–·æ˜¯å¦åœ¨ç§»å‹•
            player.isMoving = (Math.abs(moveForward) > 0.1 || Math.abs(strafe) > 0.1);

            // æ­»äº¡åˆ¤å®š
            if (player.isMoving && (boss.state === 'awake' || (boss.state === 'turning' && boss.mesh.rotation.y < 1.5))) {
                endGame();
                return;
            }

            // --- æ‰‹éƒ¨å‹•ç•« ---
            if (handsGroup) {
                const leftHand = handsGroup.children[0];
                const rightHand = handsGroup.children[1];
                
                if (player.hasEgg) {
                    // æŠ±è›‹æ¨¡å¼
                    eggInHand.visible = true;
                    leftHand.position.x = THREE.MathUtils.lerp(leftHand.position.x, 0.12, 0.1);
                    rightHand.position.x = THREE.MathUtils.lerp(rightHand.position.x, -0.12, 0.1);
                    leftHand.rotation.z = THREE.MathUtils.lerp(leftHand.rotation.z, -0.5, 0.1);
                    rightHand.rotation.z = THREE.MathUtils.lerp(rightHand.rotation.z, 0.5, 0.1);

                    if (player.isMoving) {
                        const bob = Math.sin(Date.now() * 0.01) * 0.02;
                        handsGroup.position.y = -0.15 + bob;
                    }
                } else {
                    // æº–å‚™æ¨¡å¼
                    eggInHand.visible = false;
                    leftHand.position.x = THREE.MathUtils.lerp(leftHand.position.x, 0.3, 0.1);
                    rightHand.position.x = THREE.MathUtils.lerp(rightHand.position.x, -0.3, 0.1);
                    leftHand.rotation.z = THREE.MathUtils.lerp(leftHand.rotation.z, 0.2, 0.1);
                    rightHand.rotation.z = THREE.MathUtils.lerp(rightHand.rotation.z, -0.2, 0.1);

                    if (player.isMoving) {
                        const bob = Math.sin(Date.now() * 0.015) * 0.03;
                        handsGroup.position.y = -0.2 + bob; 
                        handsGroup.rotation.z = Math.sin(Date.now() * 0.008) * 0.03;
                    } else {
                        const breath = Math.sin(Date.now() * 0.003) * 0.005;
                        handsGroup.position.y = -0.2 + breath;
                        handsGroup.rotation.z = 0;
                    }
                }
            }

            // --- ç‰©ç†ç§»å‹• ---
            if (player.isMoving) {
                // è¨ˆç®—åŸºç¤é€Ÿåº¦ (è€ƒæ…®è² é‡)
                let currentSpeed = CONFIG.moveSpeed * dt;
                if (player.hasEgg) currentSpeed *= CONFIG.eggWeightFactor;

                // é™åˆ¶æ–æ¡¿å¼·åº¦ (æ¨ä¸€é»é»èµ°æ…¢é»)
                const inputMagnitude = Math.min(1, Math.sqrt(moveForward*moveForward + strafe*strafe)) || 1;
                const finalSpeed = currentSpeed * inputMagnitude;
                
                // æ ¹æ“šç•¶å‰æœå‘ (Yaw) è¨ˆç®—ä½ç§»
                // Forward: -Z (sin(yaw) for X, cos(yaw) for Z)
                const dx = Math.sin(player.yaw) * moveForward;
                const dz = Math.cos(player.yaw) * moveForward; 
                
                // Strafe: Right (cos(yaw) for X, -sin(yaw) for Z)
                const sx = Math.cos(player.yaw) * strafe;
                const sz = -Math.sin(player.yaw) * strafe;

                player.x -= (dx - sx) * finalSpeed; 
                player.z -= (dz + sz) * finalSpeed;
                
                // é‚Šç•Œ
                player.x = Math.max(-40, Math.min(40, player.x)); 
                
                // é ­éƒ¨æ™ƒå‹•
                player.y = 2 + Math.sin(Date.now() * 0.012) * 0.15;
            } else {
                player.y = THREE.MathUtils.lerp(player.y, 2, 0.1);
            }

            camera.position.set(player.x, player.y, player.z);
            camera.rotation.x = player.pitch;
            camera.rotation.y = player.yaw;

            // UI æ›´æ–°
            let dist;
            if (!player.hasEgg) {
                dist = Math.max(0, Math.floor(player.z - CONFIG.nestDistance));
            } else {
                dist = Math.max(0, Math.floor(CONFIG.startDistance - player.z));
            }
            ui.distDisplay.innerText = dist;

            checkObjectives();
        }

        function checkObjectives() {
            // å·è›‹
            if (!player.hasEgg && player.z <= CONFIG.nestDistance && Math.abs(player.x) < 8) {
                player.hasEgg = true;
                eggMesh.visible = false; 
                showObjectiveMessage("æ‹¿åˆ°è›‹äº†ï¼å¿«è·‘ï¼", "text-yellow-400");
                updateObjectiveUI();
            }

            // å›å·¢
            if (player.hasEgg && player.z >= CONFIG.startDistance - 2 && Math.abs(player.x) < 10) {
                player.score++;
                player.hasEgg = false;
                eggMesh.visible = true; 
                ui.scoreDisplay.innerText = player.score;
                
                difficulty += 0.3;
                
                showObjectiveMessage(`æˆåŠŸï¼å¾—åˆ† +1`, "text-green-400");
                updateObjectiveUI();
            }
        }

        function animate() {
            if (player.dead) return;
            requestAnimationFrame(animate);
            
            const now = performance.now();
            const dt = now - lastTime;
            lastTime = now;

            updateBoss(dt);
            updatePlayer(dt);
            renderer.render(scene, camera);
        }

        function setUiState(state) {
            ui.startScreen.classList.add('hidden');
            ui.endScreen.classList.add('hidden');
            if (state === 'start') ui.startScreen.classList.remove('hidden');
            if (state === 'lose') ui.endScreen.classList.remove('hidden');
        }

        ui.startBtn.addEventListener('click', startGame);
        ui.restartBtn.addEventListener('click', startGame);

        init3D();
        setUiState('start');
        renderer.render(scene, camera); 
    </script>
</body>
</html>
